<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Garden Cultivation Robot | Alvaro Guerra</title>
    <link rel="stylesheet" href="../styles.css">
</head>
<body>
    <header>
        <a href="../index.html" class="logo-link">
            <div class="logo-name">
                <img src="../images/logo.png" alt="Logo" class="logo">
                <h2>Engineering Portfolio</h2>
            </div>
        </a>
        <nav>
            <a href="../index.html">Home</a> |
            <a href="about.html">About</a> |
            <a href="../files/Resume.pdf">Resume</a> |
            <a href="../index.html">Projects</a>
        </nav>
    </header>

    <!-- ─────────── MAIN CONTENT ─────────── -->
    <section>
        <!-- TITLE BLOCK -->
        <div class = "centered-content">
        <h1 style="color: #ffffff; text-align: center;">Garden Cultivation Robot</h1>
        <h2 style="color: #ffffff; text-align: center";><i>GCR</i></h2>
        <h3 style="color: #ffffff; text-align: center;">Senior Engineering Capstone Project – Texas A&amp;M University</h3>
        <br>
        
        <!-- OVERVIEW -->
        <p style="color: #ffffff;">
            The Garden Cultivation Robot, <i>GCR</i> was developed to address the physical challenges associated with home gardening, especially for elderly and mobility-limited individuals. The team's goal was to create a modular, remotely-controlled robot capable of traversing a 50-foot garden row while delivering water and fertilizer to plants. Key design goals included modularity, maneuverability, durability, and ease of use.
The final prototype successfully achieved its core objectives. The robot features a modular aluminum 8020 chassis with ABS and PETG enclosures, a twin DC motor drivetrain using chain and sprocket assemblies, and two modular subsystems for watering and fertilizing. The electronic control system was built around a dual-Arduino master-slave architecture, ensuring responsive wireless remote control with minimal signal latency. Failure risk assessments, including FMECA and Fault Tree Analysis, identified drivetrain misalignment and battery depletion as key concerns; these risks were addressed through design modifications, rigorous mechanical assembly, and iterative electronic debugging. The robot met major performance targets, including a 0.01 m turning radius, a 26% improvement in consumable volume, and a final project cost of $2,301.97, remaining within the approved contingency budget.
        </p>
        <p style="color: #ffffff; text-align: center; margin-top: 1rem;">
            <a href="../files/Final Report.pdf" target="_blank" style="color: #87CEFA; text-decoration: underline;">View Full Project Report (PDF)</a>
        </p>
        <br>
        <!-- ROLE & SCOPE -->
        <h3 style="color:#ffffff;">| My Role &amp; Scope</h3>
        <ul style="color:#ffffff; font-size:1.3rem;">
            <li>Worked from concept to field-ready prototype, covering CAD, electronics, code, and testing.</li>
            <li>Designed modular <strong>8020 aluminum chassis</strong>.</li>
            <li>Developed entire CAD assembly from concept to detailed drawings.</li>
            <li>Developed <strong>dual-Arduino master-slave firmware</strong> with 2.4 GHz RF link for low-latency remote control.</li>
        </ul>
        <br>
        <br>
        <!-- SYSTEM ARCHITECTURE TABLE -->
        <h3 style="color:#ffffff;">| System Architecture</h3>
        <div style="overflow-x:auto;">
        <table style="width:100%;border-collapse:collapse;color:#ffffff;text-align:left; font-size:1.3rem;">
            <thead>
                <tr>
                    <th style="border-bottom:1px solid #888;">Sub-system</th>
                    <th style="border-bottom:1px solid #888;">Hardware / Software</th>
                    <th style="border-bottom:1px solid #888;">Why</th>
                    <th style="border-bottom:1px solid #888;">Source</th>
                </tr>
            </thead>
            <tbody>
                <tr><td>Chassis</td><td>8020 alu extrusion + ABS/PETG panels</td><td>Modular &amp; weather-resistant</td><td>80/20 Inc.</td></tr>
                <tr><td>Drivetrain</td><td>2 × 12 V DC gear-motors + chain &amp; sprocket</td><td>High torque, tight turns</td><td>Pololu / Tsubaki</td></tr>
                <tr><td>Watering</td><td>12 V water pumps + PVC piping</td><td>Precise metering</td><td>Autobonics</td></tr>
                <tr><td>Fertilizing</td><td>Venturi spray nozzle</td><td>Uniform coverage</td><td>Custom</td></tr>
                <tr><td>Controller</td><td>Arduino Uno (master) + Nano (slave) + nRF24L01</td><td>Low-latency RF</td><td>Arduino / Nordic</td></tr>
                <tr><td>Power</td><td>12 V 9 Ah LiFePO₄</td><td>Long endurance</td><td>Bioenno Power</td></tr>
            </tbody>
        </table>
        </div>
        <br>
        <img src="../images/gcr_iso.png" alt="GCR CAD model" style="display: block; margin: 0 auto;">
        <br>
        <br>
        <!-- ELECTRONICS & CONTROL -->
        <h3 style="color:#ffffff;">| Electronics &amp; Control</h3>
        <div style="display:flex;justify-content:space-between;align-items:center;flex-wrap:wrap;gap:1rem;">
            <img src="../images/electronic_simple.png" alt="Block diagram" style="width: 32%;height:auto;">
            <img src="../images/gcr_schematic.png" alt="Schematic" style="width: 32%;height:auto;">
            <img src="../images/gcr_RC.png" alt="RC Transmitter" style="width: 32%;height:auto;">
        </div>
        <p style="color:#ffffff; text-align:center;font-size:1em;">Dual-Arduino architecture, wiring schematic, and custom RC remote.</p>
        <br>

        <!-- Electronics Housing Design -->
        <p style="color:#ffffff;">
            A custom electronics housing was designed and 3D printed to securely mount the battery and electronic components within the chassis. The housing features dedicated compartments for the battery, Arduino controllers, and power distribution boards, improving cable organization and preventing interference with the moving chain drive system. The design incorporates mounting points for secure attachment to the 8020 frame and includes ventilation slots for thermal management.
        </p>
        <div style="display:flex;justify-content:space-between;align-items:center;flex-wrap:wrap;gap:1rem;">
            <img src="../images/gcr_elecHousingIso.png" alt="Electronics housing isometric view" style="width:32%;height:auto;">
            <img src="../images/gcr_elecHousingTop.png" alt="Electronics housing top view" style="width:32%;height:auto;">
            <img src="../images/gcr_electronicHousing.png" alt="Electronics housing implementation" style="width:32%;height:auto;">
        </div>
        <p style="color:#ffffff; text-align:center;font-size:1em;">CAD design and implementation of the custom electronics housing showing component layout and mounting features.</p>
        <br>

        <!-- SUB-SYSTEMS -->
        <h3 style="color:#ffffff;">| Watering &amp; Fertilizing Modules</h3>
        <div style="display:flex;justify-content:space-between;align-items:center;flex-wrap:wrap;gap:1rem;">
            <img src="../images/gcr_watertank.png" alt="Water tank" style="width:32%;height:auto;">
            <img src="../images/water_tank_pumps.png" alt="Pump array" style="width:32%;height:auto;">
            <img src="../images/gcr_fert.png" alt="Fertilizer module" style="width:32%;height:auto;">
        </div>
        <br>
        <!-- MANUFACTURING & DRIVETRAIN -->
        <h3 style="color:#ffffff;">| Manufacturing &amp; Drivetrain</h3>
        <div style="display:flex;justify-content:space-between;align-items:center;flex-wrap:wrap;gap:1rem;">
            <img src="../images/chassis_build.png" alt="Chassis build" style="width:48%;height:auto;">
            <img src="../images/double_motor.png" alt="Twin motor drivetrain" style="width:48%;height:auto;">
        </div>

        <!-- ARDUINO CODE OVERVIEW -->
        <h3 style="color:#ffffff;">| Arduino Firmware Overview</h3>
        <p style="color:#ffffff;">
            The firmware is split across two sketches – <code>Master_Code.ino</code> on an Arduino&nbsp;Uno and <code>Slave_Code.ino</code> on an Arduino&nbsp;Nano. The Uno reads raw PWM signals from the FlySky&nbsp;FS-i6X receiver, steers the drivetrain at 75&nbsp;Hz, and forwards any plant-care commands to the Nano over a 400&nbsp;kHz I<sup>2</sup>C bus (address&nbsp;0×08). The Nano in turn drives the high-current actuator, pumps, and conveyor motor so power wiring stays short and serviceable.
        </p>

        <!-- Code Overview -->
        <div style="background:#111;color:#0f0;padding:1rem;font-size:0.9rem;margin:1rem 0;">
            <!-- Master Arduino Code -->
            <button id="toggleMasterCodeBtn" onclick="toggleCode('masterCode', 'toggleMasterCodeBtn', 'Master Arduino')" style="background-color: #0056b3; color: white; padding: 8px 15px; margin-bottom: 10px; border: none; border-radius: 4px; cursor: pointer;">View Master Arduino Code</button>
            <div id="masterCode" style="display: none; overflow-x:auto;">
                <h4 style="color:#0f0;margin-top:0;">Master Code (Arduino Uno)</h4>
                <pre><code>// ───────── Motor Pins ─────────
                #include <Wire.h>

                    // Define Motor A (Right Motor) Pins
                    #define PWM_A 9
                    #define A1 7
                    #define A2 6
                    
                    // Define Motor B (Left Motor) Pins
                    #define PWM_B 10
                    #define B1 11
                    #define B2 12
                    
                    // Receiver input pins for motor control
                    const int steeringPin = 2;
                    const int throttlePin = 3;
                    
                    // RC input channels
                    #define CHANNEL_PIN 5   // FS-i6X channel for pump control
                    const int actuatorPin = 13; // Actuator control signal
                    const int motorPin = 4;     // 12V motor control signal
                    
                    // Input pulse range (FS-i6X default)
                    #define PULSE_MIN 980
                    #define PULSE_MAX 1980
                    
                    // Motor speed range
                    #define SPEED_MIN -255
                    #define SPEED_MAX 255
                    
                    // Deadzone threshold
                    #define DEADZONE 20
                    
                    // Timing for non-blocking execution
                    unsigned long lastUpdate = 0;
                    const int updateInterval = 50;
                    
                    // === Latency Testing Variables ===
                    unsigned long lastSignalTime = 0;
                    float latencySum = 0;
                    unsigned long latencyCount = 0;
                    float maxLatency = 0;
                    unsigned long startTime = 0;
                    const unsigned long loggingDurationMs = 30000; // Log for 30 seconds
                    bool latencyDone = false;
                    
                    
                    void setup() {
                        startTime = millis();
                        Serial.println("Time(ms),Latency(ms)");
                    
                    
                        Serial.begin(9600);
                        Wire.begin();  // Start I2C as master
                    
                        // Set motor control pins as outputs
                        pinMode(PWM_A, OUTPUT);
                        pinMode(A1, OUTPUT);
                        pinMode(A2, OUTPUT);
                        pinMode(PWM_B, OUTPUT);
                        pinMode(B1, OUTPUT);
                        pinMode(B2, OUTPUT);
                    
                        // Set receiver input pins
                        pinMode(steeringPin, INPUT);
                        pinMode(throttlePin, INPUT);
                        pinMode(CHANNEL_PIN, INPUT);
                        pinMode(actuatorPin, INPUT);
                        pinMode(motorPin, INPUT);
                    }
                    
                    void loop() {
                        if (!latencyDone) {
                          pulseIn(steeringPin, HIGH);
                          unsigned long now = micros();
                          float latency = (now - lastSignalTime) / 1000.0;
                          lastSignalTime = now;
                    
                        if (latencyCount > 0) {
                          latencySum += latency;
                          if (latency > maxLatency) maxLatency = latency;
                    
                          Serial.print(millis());
                          Serial.print(",");
                          Serial.println(latency, 3);
                        }
                    
                        latencyCount++;
                    
                        if (millis() - startTime >= loggingDurationMs) {
                          latencyDone = true;
                          float averageLatency = latencySum / (latencyCount - 1);
                          Serial.println();
                          Serial.println("=== Summary ===");
                          Serial.print("Average Latency (ms): ");
                          Serial.println(averageLatency, 3);
                          Serial.print("Max Latency (ms): ");
                          Serial.println(maxLatency, 3);
                          Serial.println("================");
                        }
                      }
                    
                        if (millis() - lastUpdate >= updateInterval) {
                            lastUpdate = millis();
                    
                            int throttle, steering, pumpSignal;
                            readInputs(throttle, steering, pumpSignal);
                    
                            int rightMotorSpeed, leftMotorSpeed;
                            calculateMotorSpeeds(throttle, steering, rightMotorSpeed, leftMotorSpeed);
                    
                            applyMotorSpeeds(rightMotorSpeed, leftMotorSpeed);
                    
                            // Read signals and send to slave arduino
                            int actuatorSignal = pulseIn(actuatorPin, HIGH);
                            int motorSignal = pulseIn(motorPin, HIGH);
                            sendToSlave(actuatorSignal, motorSignal, pumpSignal);
                    
                            debugOutput(throttle, steering, rightMotorSpeed, leftMotorSpeed, pumpSignal, actuatorSignal, motorSignal);
                        }
                    }
                    
                    void readInputs(int &throttle, int &steering, int &pumpSignal) {
                        throttle = pulseIn(throttlePin, HIGH);
                        steering = pulseIn(steeringPin, HIGH);
                        pumpSignal = pulseIn(CHANNEL_PIN, HIGH);
                    
                        throttle = map(throttle, PULSE_MIN, PULSE_MAX, SPEED_MIN, SPEED_MAX);
                        steering = map(steering, PULSE_MIN, PULSE_MAX, SPEED_MIN, SPEED_MAX);
                    
                        throttle = (abs(throttle) < DEADZONE) ? 0 : throttle;
                        steering = (abs(steering) < DEADZONE) ? 0 : steering;
                    }
                    
                    void calculateMotorSpeeds(int throttle, int steering, int &rightMotorSpeed, int &leftMotorSpeed) {
                        if (throttle == 0) {
                            rightMotorSpeed = -steering;
                            leftMotorSpeed = steering;
                        } else {
                            rightMotorSpeed = constrain(throttle - steering / 2, SPEED_MIN, SPEED_MAX);
                            leftMotorSpeed  = constrain(throttle + steering / 2, SPEED_MIN, SPEED_MAX);
                    
                            if (steering == 0) {
                                rightMotorSpeed = leftMotorSpeed = throttle;
                            }
                        }
                    }
                    
                    void applyMotorSpeeds(int rightMotorSpeed, int leftMotorSpeed) {
                        setMotorSpeed(PWM_A, A1, A2, rightMotorSpeed);
                        setMotorSpeed(PWM_B, B1, B2, -leftMotorSpeed);  // Inverted for tank drive
                    }
                    
                    void setMotorSpeed(int pwmPin, int pin1, int pin2, int speed) {
                        digitalWrite(pin1, speed > 0);
                        digitalWrite(pin2, speed < 0);
                        analogWrite(pwmPin, abs(speed));
                    }
                    
                    // NEW: Send actuator, motor, and pump signals to slave arduino
                    void sendToSlave(int actuatorSignal, int motorSignal, int pumpSignal) {
                        Wire.beginTransmission(8); // Slave address
                    
                        Wire.write((byte)(actuatorSignal >> 8));
                        Wire.write((byte)(actuatorSignal & 0xFF));
                        Wire.write((byte)(motorSignal >> 8));
                        Wire.write((byte)(motorSignal & 0xFF));
                        Wire.write((byte)(pumpSignal >> 8));
                        Wire.write((byte)(pumpSignal & 0xFF));
                    
                        Wire.endTransmission();
                    }
                    
                    void debugOutput(int throttle, int steering, int rightMotorSpeed, int leftMotorSpeed,
                                     int pumpSignal, int actuatorSignal, int motorSignal) {
                        Serial.print("Throttle: "); Serial.print(throttle);
                        Serial.print(" | Steering: "); Serial.print(steering);
                        Serial.print(" | Left Motor: "); Serial.print(leftMotorSpeed);
                        Serial.print(" | Right Motor: "); Serial.print(rightMotorSpeed);
                        Serial.print(" | Pump: "); Serial.print(pumpSignal);
                        Serial.print(" | Actuator: "); Serial.print(actuatorSignal);
                        Serial.print(" | Motor: "); Serial.println(motorSignal);
                    }
}</code></pre>
            </div>
            <hr style="border-color: #333; margin: 15px 0;">

            <!-- Slave Arduino Code -->
            <button id="toggleSlaveCodeBtn" onclick="toggleCode('slaveCode', 'toggleSlaveCodeBtn', 'Slave Arduino')" style="background-color: #0056b3; color: white; padding: 8px 15px; margin-bottom: 10px; border: none; border-radius: 4px; cursor: pointer;">View Slave Arduino Code</button>
            <div id="slaveCode" style="display: none; overflow-x:auto;">
                <h4 style="color:#0f0;">Slave Code (Arduino Nano)</h4>
                <pre><code>// ───── Pin Map ─────
                #include <Wire.h>

                    // === Pin Definitions ===
                    // Linear Actuator (L298N Driver 2)
                    #define ACTUATOR_PWM 9
                    #define ACTUATOR_IN1 7
                    #define ACTUATOR_IN2 12  
                    
                    // 12V Motor (L298N Driver 2)
                    #define MOTOR_IN1 4
                    #define MOTOR_IN2 2
                    #define MOTOR_ENA 8
                    
                    // Pumps (Motor Driver 1)
                    #define PUMP_A_ENA 10
                    #define PUMP_B_ENB 6
                    
                    // === State Variables ===
                    int prevActSignal = -1;
                    const int deadzone = 10;
                    
                    void setup() {
                      Serial.begin(9600);
                      Wire.begin(8); // I2C Slave Address
                      Wire.onReceive(receiveEvent);
                    
                      // Set pin modes
                      pinMode(ACTUATOR_PWM, OUTPUT);
                      pinMode(ACTUATOR_IN1, OUTPUT);
                      pinMode(ACTUATOR_IN2, OUTPUT);
                      pinMode(MOTOR_IN1, OUTPUT);
                      pinMode(MOTOR_IN2, OUTPUT);
                      pinMode(MOTOR_ENA, OUTPUT);
                      pinMode(PUMP_A_ENA, OUTPUT);
                      pinMode(PUMP_B_ENB, OUTPUT);
                    
                      // Initialize outputs to LOW
                      digitalWrite(MOTOR_IN1, LOW);
                      digitalWrite(MOTOR_IN2, LOW);
                      analogWrite(MOTOR_ENA, 0);
                      digitalWrite(ACTUATOR_IN1, LOW);
                      digitalWrite(ACTUATOR_IN2, LOW);
                      analogWrite(ACTUATOR_PWM, 0);
                      analogWrite(PUMP_A_ENA, 0);
                      analogWrite(PUMP_B_ENB, 0);
                    }
                    
                    void loop() {
                      // I2C events handled in receiveEvent()
                    }
                    
                    void receiveEvent(int howMany) {
                      if (howMany >= 6) {
                        int actSignal = (Wire.read() << 8) | Wire.read();
                        int motorSignal = (Wire.read() << 8) | Wire.read();
                        int pumpSignal = (Wire.read() << 8) | Wire.read();
                    
                        // === Debug Print ===
                        Serial.print("Received | Actuator: ");
                        Serial.print(actSignal);
                        Serial.print(" | Motor: ");
                        Serial.print(motorSignal);
                        Serial.print(" | Pump: ");
                        Serial.println(pumpSignal);
                    
                        // === Motor Control ===
                        if (motorSignal > 1500) {
                          Serial.println("Motor ON");
                          digitalWrite(MOTOR_IN1, HIGH);
                          digitalWrite(MOTOR_IN2, LOW);
                          analogWrite(MOTOR_ENA, 255);
                        } else {
                          Serial.println("Motor OFF");
                          digitalWrite(MOTOR_IN1, LOW);
                          digitalWrite(MOTOR_IN2, LOW);
                          analogWrite(MOTOR_ENA, 0);
                        }
                    
                        // === Pump Control ===
                        if (pumpSignal > 1500) {
                          Serial.println("Pumps ON");
                          analogWrite(PUMP_A_ENA, 255);
                          analogWrite(PUMP_B_ENB, 255);
                        } else {
                          Serial.println("Pumps OFF");
                          analogWrite(PUMP_A_ENA, 0);
                          analogWrite(PUMP_B_ENB, 0);
                        }
                    
                        // === Actuator Control ===
                        if (actSignal < 1010) {
                          Serial.println("Actuator FULL Retract");
                          digitalWrite(ACTUATOR_IN1, LOW);
                          digitalWrite(ACTUATOR_IN2, HIGH);
                          analogWrite(ACTUATOR_PWM, 255);
                        } else if (actSignal > 1980) {
                          Serial.println("Actuator FULL EXTEND");
                          digitalWrite(ACTUATOR_IN1, HIGH);
                          digitalWrite(ACTUATOR_IN2, LOW);
                          analogWrite(ACTUATOR_PWM, 255);
                        } else {
                          int delta = 0;
                    
                          if (prevActSignal == -1) {
                            prevActSignal = actSignal;
                            Serial.println("Actuator INIT");
                          } else {
                            delta = actSignal - prevActSignal;
                    
                            if (delta > deadzone) {
                              Serial.println("Actuator Extending");
                              digitalWrite(ACTUATOR_IN1, HIGH);
                              digitalWrite(ACTUATOR_IN2, LOW);
                              analogWrite(ACTUATOR_PWM, 255);
                            } else if (delta < -deadzone) {
                              Serial.println("Actuator Retracting");
                              digitalWrite(ACTUATOR_IN1, LOW);
                              digitalWrite(ACTUATOR_IN2, HIGH);
                              analogWrite(ACTUATOR_PWM, 255);
                            } else {
                              Serial.println("Actuator STOPPED");
                              digitalWrite(ACTUATOR_IN1, LOW);
                              digitalWrite(ACTUATOR_IN2, LOW);
                              analogWrite(ACTUATOR_PWM, 0);
                            }
                    
                            prevActSignal = actSignal;
                          }
                        }
                      }
                    }
}</code></pre>
            </div>
            <hr style="border-color: #333; margin: 15px 0;">

            <!-- Raspberry Pi Sensor Visualization Code -->
            <button id="togglePiCodeBtn" onclick="toggleCode('piCode', 'togglePiCodeBtn', 'Raspberry Pi Sensor')" style="background-color: #0056b3; color: white; padding: 8px 15px; margin-bottom: 10px; border: none; border-radius: 4px; cursor: pointer;">View Raspberry Pi Sensor Code</button>
            <div id="piCode" style="display: none; overflow-x:auto;">
                <h4 style="color:#0f0;">Raspberry Pi Sensor Code (DHT22 &amp; NEO-6M)</h4>
                <pre><code>import time
from datetime import datetime
import board
import adafruit_dht
import serial
import pynmea2
import matplotlib.pyplot as plt
import matplotlib.animation as animation

# Set up DHT22 sensor - connected to GPIO 18
dht_device = adafruit_dht.DHT22(board.D18)  # GPIO 18 for DHT-22

# Set up GPS - connected to GPIO 14 (TX) and 15 (RX)
# On newer Raspberry Pi models, the primary UART is often at /dev/serial0
gps_port = "/dev/serial0"  # Try this instead of /dev/ttyAMA0
# Alternative options if serial0 doesn't work:
# gps_port = "/dev/ttyS0"
# gps_port = "/dev/ttyUSB0"  # If using a USB-to-Serial adapter
gps_baudrate = 9600
try:
    ser = serial.Serial(gps_port, gps_baudrate, timeout=1)
    print(f"Successfully connected to GPS on {gps_port}")
except serial.SerialException as e:
    print(f"Error opening serial port {gps_port}: {e}")
    print("Available ports may include:")
    import glob
    available_ports = glob.glob("/dev/tty*")
    for port in available_ports:
        if "ttyS" in port or "ttyAMA" in port or "ttyUSB" in port or "serial" in port:
            print(f"  - {port}")
    raise

# Data storage
timestamps = []
temperature_data = []
humidity_data = []
latitude_data = []
longitude_data = []

# Plot setup
fig, (ax1, ax2) = plt.subplots(2, 1)
fig.suptitle("Real-Time Sensor Data")

def update_plot(frame):
    global timestamps, temperature_data, humidity_data, latitude_data, longitude_data

    # Read DHT22 sensor
    try:
        temp = dht_device.temperature
        humidity = dht_device.humidity
    except RuntimeError as e:
        print(f"DHT error: {e}")
        temp, humidity = None, None

    # Read GPS data
    lat, lon = None, None
    try:
        line = ser.readline().decode('utf-8', errors='ignore')
        if line.startswith('$GPGGA'):
            msg = pynmea2.parse(line)
            lat, lon = msg.latitude, msg.longitude
    except Exception as e:
        print(f"GPS error: {e}")

    # Store values
    timestamps.append(time.time())
    temperature_data.append(temp)
    humidity_data.append(humidity)
    latitude_data.append(lat)
    longitude_data.append(lon)

    # Keep last 100 values for visualization
    timestamps, temperature_data, humidity_data = timestamps[-100:], temperature_data[-100:], humidity_data[-100:]
    latitude_data, longitude_data = latitude_data[-100:], longitude_data[-100:]

    # Update Temperature & Humidity Plot
    ax1.clear()
    ax1.plot(timestamps, temperature_data, label="Temperature (&deg;C)", color='r')
    ax1.plot(timestamps, humidity_data, label="Humidity (%)", color='b')
    ax1.set_xlabel("Time")
    ax1.set_ylabel("Values")
    ax1.legend()
    ax1.grid()

    # Update GPS Plot
    ax2.clear()
    ax2.scatter(longitude_data, latitude_data, label="GPS Location", color='g')
    ax2.set_xlabel("Longitude")
    ax2.set_ylabel("Latitude")
    ax2.legend()
    ax2.grid()

# Start live update
ani = animation.FuncAnimation(fig, update_plot, interval=1000)
plt.show()
</code></pre>
            </div>
        </div>

        <p style="color:#ffffff;">
            The code implements a robust control system with several key features:
        </p>
        <ul style="color:#ffffff;font-size:1.1rem;">
            <li><strong>Master Controller (Uno)</strong>
                <ul>
                    <li>Reads 5 RC channels (throttle, steering, pump, actuator, motor) at 20 Hz</li>
                    <li>Implements differential drive with deadzone compensation</li>
                    <li>Maps RC pulses (980-1980 µs) to motor speeds (-255 to 255)</li>
                    <li>Forwards actuator, motor, and pump commands to Slave Nano via I<sup>2</sup>C</li>
                    <li>Includes serial debug output for real-time monitoring and latency testing</li>
                </ul>
            </li>
            <li><strong>Slave Controller (Nano)</strong>
                <ul>
                    <li>Receives commands from Master Uno via I<sup>2</sup>C</li>
                    <li>Controls high-current devices: linear actuator, conveyor motor, and dual pumps</li>
                    <li>Implements threshold-based control for binary devices (pumps, motor)</li>
                    <li>Uses position-based control with deadzone for the linear actuator</li>
                    <li>Includes serial debug output for received commands and device states</li>
                </ul>
            </li>
            <li><strong>Raspberry Pi (Sensor Visualization)</strong>
                <ul>
                    <li>Interfaces with DHT22 sensor for temperature and humidity readings (via GPIO)</li>
                    <li>Connects to NEO-6M GPS module for location data (via Serial/UART)</li>
                    <li>Includes error handling for sensor and serial port connections</li>
                    <li>Stores the latest 100 readings for temperature, humidity, latitude, and longitude</li>
                    <li>Uses Matplotlib to generate real-time animated plots: 
                        <ul>
                            <li>Temperature and humidity over time</li>
                            <li>GPS coordinates (latitude vs. longitude)</li>
                        </ul>
                    </li>
                    <li>Updates plots at 1-second intervals</li>
                </ul>
            </li>
        </ul>
        <br>

        <!-- ANALYSIS & VERIFICATION -->
        <h3 style="color:#ffffff;">| Analysis &amp; Verification</h3>
        <ul style="color:#ffffff;">
            <li><strong>Field trials</strong> – Completed 50-ft traversal &amp; watering in 6 min with 0.01 m turn radius.</li>
            <li><strong>Throughput testing</strong> – 26 % higher consumable capacity than initial design spec.</li>
            <li><strong>Reliability</strong> – 60-hour endurance run with zero drivetrain or electronics failures.</li>
            <li><strong>FEA</strong> – Aluminum 6061 Yield Strength: 5.515e7 Nsm. Horizontal load force: 83.4 lbf (equivalent to 10 gallon water weight). FOS: 3.78. 7 screw connections along 20 inch tank span length.</li>
        </ul>
        <div style="display:flex;justify-content:space-between;align-items:center;flex-wrap:wrap;gap:1rem;margin:1rem 0;">
            <img src="../images/gcr_rail.png" alt="GCR rail assembly" style="width:48%;height:auto;">
            <img src="../images/rail_fea.jpg" alt="FEA analysis of rail assembly" style="width:48%;height:auto;">
        </div>
        <br>
        <br>

        <!-- IMPACT & LESSONS LEARNED -->
        <h3 style="color:#ffffff;">| Impact &amp; Lessons Learned</h3>
        <p style="color:#ffffff;">
            Bringing GCR from blank sheet to field test deepened my appreciation for <strong>end-to-end systems thinking</strong>:
            translating user pain-points into requirements, validating them with FMECA, and closing the loop with
            instrumented field trials.  I gained hands-on experience in <em>design-for-assembly</em> (8020 framing, chain
            alignment jigs) and <em>design-for-serviceability</em> (tool-free module swaps).  Debugging the dual-Arduino
            firmware taught me the value of layered diagnostics and watchdog timers.  Working with a cross-functional team
            hardened my soft skills—weekly design reviews, Gantt tracking, and rapid knowledge sharing turned five students
            into a cohesive engineering unit.
        </p>
        <br>
        <hr style="border:0;border-top:1px solid #666;margin:3rem 0;">
        <p style="color:#ffffff;text-align:center;font-weight:bold;">
            TL;DR – Built a modular dual-Arduino garden robot that waters &amp; fertilizes 50 ft rows, hits 0.01 m turns, and boosts capacity by 26 % — all under budget.
        </p>
        <hr style="border:0;border-top:1px solid #757575;margin:3rem 0;">
        </div>
    </section>

    <!-- PHOTO & VIDEO GALLERY -->
    <div class="centered-content">
    <h3 style="color:#ffffff;">| Gallery</h3>
    <div style="display:flex;flex-wrap:wrap;gap:1.5rem;justify-content:center;">
        <figure style="flex:1 1 45%;max-width:45%;text-align:center;">
            <img src="../images/gcr_iso.png" alt="GCR ISO assembly" style="width:100%;height:auto;">
            <figcaption style="color:#ffffff;font-size:0.9rem;">ISO view during final assembly – shows modular 8020 frame and protective side panels.</figcaption>
        </figure>
        <figure style="flex:1 1 45%;max-width:45%;text-align:center;">
            <img src="../images/gcr_chassis_top.png" alt="Top-down chassis" style="width:100%;height:auto;">
            <figcaption style="color:#ffffff;font-size:0.9rem;">Top-down look highlighting water &amp; fertilizer tanks and dual-Arduino enclosure.</figcaption>
        </figure>
        <figure style="flex:1 1 45%;max-width:45%;text-align:center;">
            <img src="../images/gcr_side.png" alt="Side profile" style="width:100%;height:auto;">
            <figcaption style="color:#ffffff;font-size:0.9rem;">Side profile illustrating compact ground clearance and chain-drive layout.</figcaption>
        </figure>
        <figure style="flex:1 1 45%;max-width:45%;text-align:center;">
            <img src="../images/gcr_linearactuator.jpg" alt="Linear actuator" style="width:100%;height:auto;">
            <figcaption style="color:#ffffff;font-size:0.9rem;">Close-up of the 100&nbsp;mm linear actuator responsible for fertilizer hatch-dispense control.</figcaption>
        </figure>
        <figure style="flex:1 1 45%;max-width:45%;text-align:center;">
            <img src="../images/gcr_drivetrainmotorswith60AHbridge.jpg" alt="Drivetrain with 60A H-bridge" style="width:100%;height:auto;">
            <figcaption style="color:#ffffff;font-size:0.9rem;">Drivetrain bench-test – twin 12&nbsp;V gear-motors wired through a 60&nbsp;A H-bridge.</figcaption>
        </figure>
        <figure style="flex:1 1 45%;max-width:45%;text-align:center;">
            <img src="../images/gcr_3dprintmotorshaftadapter.jpg" alt="3-D printed shaft adapter" style="width:100%;height:auto;">
            <figcaption style="color:#ffffff;font-size:0.9rem;">Custom 3-D printed motor-shaft adapter that aligns fertilizer disc motor.</figcaption>
        </figure>
        <!-- Video Demonstration -->
        <figure style="flex:1 1 90%;max-width:90%;text-align:center;">
            <video controls style="width:50%;height:auto;">
                <source src="../images/gcr_testing.MOV" type="video/mp4">
                Your browser does not support the video tag. <a href="../images/gcr_testing.MOV">Download video</a>.
            </video>
            <figcaption style="color:#ffffff;font-size:0.9rem;">Field trial clip.</figcaption>
        </figure>

        <!-- Engineering Drawings Appendix -->
        <h3 style="color:#ffffff;margin-top:2rem;">| Engineering Drawings Appendix</h3>
        <div style="display:flex;flex-wrap:wrap;gap:1.5rem;justify-content:center;">
            <figure style="flex:1 1 45%;max-width:45%;text-align:center;">
                <img src="../images/gcr_engdraw1.png" alt="AndyMark CIM Motor with 16-tooth pinion" style="width:100%;height:auto;">
                <figcaption style="color:#ffffff;font-size:0.9rem;">Drawing 1: AndyMark CIM Motor with 16-tooth pinion - Primary drive motor with integrated pinion gear for chain drive system.</figcaption>
            </figure>
            <figure style="flex:1 1 45%;max-width:45%;text-align:center;">
                <img src="../images/gcr_engdraw2.png" alt="AndyMark CIM Planetary Gearbox" style="width:100%;height:auto;">
                <figcaption style="color:#ffffff;font-size:0.9rem;">Drawing 2: AndyMark CIM Planetary Gearbox - High-torque planetary gearbox for motor speed reduction and torque multiplication.</figcaption>
            </figure>
            <figure style="flex:1 1 45%;max-width:45%;text-align:center;">
                <img src="../images/gcr_engdraw3.png" alt="15-tooth motor shaft sprocket" style="width:100%;height:auto;">
                <figcaption style="color:#ffffff;font-size:0.9rem;">Drawing 3: 15-tooth motor shaft sprocket - Drive sprocket mounted on motor output shaft for chain drive system.</figcaption>
            </figure>
            <figure style="flex:1 1 45%;max-width:45%;text-align:center;">
                <img src="../images/gcr_engdraw4.png" alt="45-tooth wheel shaft sprocket" style="width:100%;height:auto;">
                <figcaption style="color:#ffffff;font-size:0.9rem;">Drawing 4: 45-tooth wheel shaft sprocket - Driven sprocket mounted on wheel shaft, providing 3:1 speed reduction.</figcaption>
            </figure>
            <figure style="flex:1 1 45%;max-width:45%;text-align:center;">
                <img src="../images/gcr_engdraw5.png" alt="Block Bearing for Wheel and Motor shafts" style="width:100%;height:auto;">
                <figcaption style="color:#ffffff;font-size:0.9rem;">Drawing 5: Block Bearing for Wheel and Motor shafts - Pillow block bearing assembly for supporting rotating shafts.</figcaption>
            </figure>
            <figure style="flex:1 1 45%;max-width:45%;text-align:center;">
                <img src="../images/gcr_engdraw6.png" alt="Submersible Water Pump" style="width:100%;height:auto;">
                <figcaption style="color:#ffffff;font-size:0.9rem;">Drawing 6: Submersible Water Pump - 12V DC submersible pump for water delivery system.</figcaption>
            </figure>
        </div>
    </div>

    <hr style="border:0;border-top:1px solid #757575;margin:3rem 0;">
</body>
<script>
function toggleCode(codeBlockId, buttonId, codeName) {
    var codeBlock = document.getElementById(codeBlockId);
    var button = document.getElementById(buttonId);
    if (codeBlock.style.display === "none") {
        codeBlock.style.display = "block";
        button.textContent = "Hide " + codeName + " Code";
    } else {
        codeBlock.style.display = "none";
        button.textContent = "View " + codeName + " Code";
    }
}
</script>
</html>